diff --git a/driver/ddramc.c b/driver/ddramc.c
index 0536b10..c193ef9 100644
--- a/driver/ddramc.c
+++ b/driver/ddramc.c
@@ -286,6 +286,242 @@ int ddram_initialize(unsigned int base_address,
 	return 0;
 }
 
+int lpddram1_initialize(unsigned int base_address,
+			unsigned int ram_address,
+			struct ddramc_register *ddramc_config)
+{
+	unsigned int ba_offset;
+	unsigned int cr = 0;
+
+	/* compute BA[] offset according to CR configuration */
+	ba_offset = (ddramc_config->cr & AT91C_DDRC2_NC) + 9;
+	if (ddramc_decodtype_is_seq(ddramc_config->cr))
+		ba_offset += ((ddramc_config->cr & AT91C_DDRC2_NR) >> 2) + 11;
+
+	ba_offset += (ddramc_config->mdr & AT91C_DDRC2_DBW) ? 1 : 2;
+
+	dbg_very_loud(" ba_offset = %x ...\n", ba_offset);
+
+	/*
+	 * Step 1: Program the memory device type into the Memory Device Register
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MDR, ddramc_config->mdr);
+
+	/*
+	 * Step 2: Program the feature of DDR2-SDRAM device into
+	 * the Timing Register, and into the Configuration Register
+	 */
+	write_ddramc(base_address, HDDRSDRC2_CR, ddramc_config->cr);
+
+	write_ddramc(base_address, HDDRSDRC2_T0PR, ddramc_config->t0pr);
+	write_ddramc(base_address, HDDRSDRC2_T1PR, ddramc_config->t1pr);
+	write_ddramc(base_address, HDDRSDRC2_T2PR, ddramc_config->t2pr);
+
+	/* Don't forget the LP registers */
+	write_ddramc(base_address, HDDRSDRC2_LPR,   AT91C_DDRC2_LPCB_DISABLED |
+						AT91C_DDRC2_CLK_FR_DISABLED |
+						AT91C_DDRC2_LPDDR2_PWOFF_DISABLED |
+						AT91C_DDRC2_PASR_(0) |
+						AT91C_DDRC2_DS_(1) |
+						AT91C_DDRC2_TIMEOUT_0 |
+						AT91C_DDRC2_ADPE_FAST |
+						AT91C_DDRC2_UPD_MR_(0)
+						);
+
+	/*
+	 * Step 3: An NOP command is issued to the DDR2-SDRAM
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_NOP_CMD);
+	*((unsigned volatile int *)ram_address) = 0;
+	/* Now, clocks which drive the DDR2-SDRAM device are enabled */
+
+	/* A minimum pause wait 200 us is provided to precede any signal toggle.
+	(6 core cycles per iteration, core is at 396MHz: min 13340 loops) */
+	udelay(200);
+
+	/*
+	 * Step 4:  An NOP command is issued to the DDR2-SDRAM
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_NOP_CMD);
+	*((unsigned volatile int *)ram_address) = 0;
+	/* Now, CKE is driven high */
+	/* wait 400 ns min */
+	udelay(1);
+
+	/*
+	 * Step 5: An all banks precharge command is issued to the DDR2-SDRAM.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_PRCGALL_CMD);
+	*((unsigned volatile int *)ram_address) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 6: An Extended Mode Register set(EMRS2) cycle is issued to chose between commercial or high
+	 * temperature operations.
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1] is set to 1 and BA[0] is set to 0.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x2 << ba_offset))) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 7: An Extended Mode Register set(EMRS3) cycle is issued
+	 * to set the Extended Mode Register to "0".
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1] is set to 1 and BA[0] is set to 1.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x3 << ba_offset))) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 8: An Extened Mode Register set(EMRS1) cycle is issued to enable DLL,
+	 * and to program D.I.C(Output Driver Impedance Control)
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1] is set to 0 and BA[0] is set to 1.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x1 << ba_offset))) = 0;
+
+	/* An additional 200 cycles of clock are required for locking DLL */
+	udelay(1);
+
+	/*
+	 * Step 9: Program DLL field into the Configuration Register to high(Enable DLL reset)
+	 */
+	cr = read_ddramc(base_address, HDDRSDRC2_CR);
+	write_ddramc(base_address, HDDRSDRC2_CR, cr | AT91C_DDRC2_RESET_DLL);
+
+	/*
+	 * Step 10: A Mode Register set(MRS) cycle is issied to reset DLL.
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1:0] bits are set to 0.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x0 << ba_offset))) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 11: An all banks precharge command is issued to the DDR2-SDRAM.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_PRCGALL_CMD);
+	*(((unsigned volatile int *)ram_address)) = 0;
+
+	/* wait 400 ns min (not needed on certain DDR2 devices) */
+	udelay(1);
+
+	/*
+	 * Step 12: Two auto-refresh (CBR) cycles are provided.
+	 * Program the auto refresh command (CBR) into the Mode Register.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_RFSH_CMD);
+	*(((unsigned volatile int *)ram_address)) = 0;
+
+	/* wait TRFC cycles min (135 ns min) extended to 400 ns */
+	udelay(1);
+
+	/* Set 2nd CBR */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_RFSH_CMD);
+	*(((unsigned volatile int *)ram_address)) = 0;
+
+	/* wait TRFC cycles min (135 ns min) extended to 400 ns */
+	udelay(1);
+
+	/*
+	 * Step 13: Program DLL field into the Configuration Register to low(Disable DLL reset).
+	 */
+	cr = read_ddramc(base_address, HDDRSDRC2_CR);
+	write_ddramc(base_address, HDDRSDRC2_CR, cr & (~AT91C_DDRC2_RESET_DLL));
+
+	/*
+	 * Step 14: A Mode Register set (MRS) cycle is issued to program
+	 * the parameters of the DDR2-SDRAM devices, in particular CAS latency,
+	 * burst length and to disable DDL reset.
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1:0] bits are set to 0.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x0 << ba_offset))) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 15: Program OCD field into the Configuration Register
+	 * to high (OCD calibration default).
+	 */
+	cr = read_ddramc(base_address, HDDRSDRC2_CR);
+	write_ddramc(base_address, HDDRSDRC2_CR, cr | AT91C_DDRC2_OCD_DEFAULT);
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 16: An Extended Mode Register set (EMRS1) cycle is issued to OCD default value.
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1] is set to 0 and BA[0] is set to 1.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x1 << ba_offset))) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 17: Program OCD field into the Configuration Register
+	 * to low (OCD calibration mode exit).
+	 */
+	cr = read_ddramc(base_address, HDDRSDRC2_CR);
+	write_ddramc(base_address, HDDRSDRC2_CR, cr & (~AT91C_DDRC2_OCD_DEFAULT));
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 18: An Extended Mode Register set (EMRS1) cycle is issued to enable OCD exit.
+	 * Perform a write access to DDR2-SDRAM to acknowledge this command.
+	 * The write address must be chosen so that BA[1] is set to 0 and BA[0] is set to 1.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD);
+	*((unsigned int *)(ram_address + (0x1 << ba_offset))) = 0;
+
+	/* wait 2 cycles min (of tCK) = 15 ns min */
+	udelay(1);
+
+	/*
+	 * Step 19: A Nornal mode command is provided.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_MR, AT91C_DDRC2_MODE_NORMAL_CMD);
+	*(((unsigned volatile int *)ram_address)) = 0;
+
+	/*
+	 * Step 20: Perform a write access to any DDR2-SDRAM address
+	 */
+	*(((unsigned volatile int *)ram_address)) = 0;
+
+	/*
+	 * Step 21: Write the refresh rate into the count field in the Refresh Timer register.
+	 */
+	write_ddramc(base_address, HDDRSDRC2_RTR, ddramc_config->rtr);
+
+	/*
+	 * Now we are ready to work on the DDRSDR
+	 *  wait for end of calibration
+	 */
+	udelay(10);
+
+	return 0;
+}
+
 #elif defined(CONFIG_LPDDR2)
 
 /*
diff --git a/include/arch/at91_ddrsdrc.h b/include/arch/at91_ddrsdrc.h
index a0b4551..fa7e85c 100644
--- a/include/arch/at91_ddrsdrc.h
+++ b/include/arch/at91_ddrsdrc.h
@@ -180,6 +180,11 @@
 #define 	AT91C_DDRC2_LPCB_POWERDOWN	(0x2UL)
 #define 	AT91C_DDRC2_LPCB_DEEP_PWD	(0x3UL)
 #define AT91C_DDRC2_CLK_FR	(0x1UL << 2)
+#define 	AT91C_DDRC2_CLK_FR_DISABLED	(0x0UL << 2)
+#define 	AT91C_DDRC2_CLK_FR_ENABLED	(0x1UL << 2)
+#define AT91C_DDRC2_LPDDR2_PWOFF (0x1UL << 3) /**< \brief (MPDDRC_LPR) LPDDR2 Power Off Bit */
+#define   AT91C_DDRC2_LPDDR2_PWOFF_DISABLED (0x0UL << 3) /**< \brief (MPDDRC_LPR) No power off sequence applied to LPDDR2. */
+#define   AT91C_DDRC2_LPDDR2_PWOFF_ENABLED (0x1UL << 3) /**< \brief (MPDDRC_LPR) A power off sequence is applied to the LPDDR2 device. CKE is forced low. */
 #define AT91C_DDRC2_PASR	(0x7UL << 4)
 #define		AT91C_DDRC2_PASR_(x)		((x & 0x7) << 4)
 #define AT91C_DDRC2_DS		(0x7UL << 8)
@@ -193,6 +198,7 @@
 #define 	AT91C_DDRC2_ADPE_FAST		(0x0UL << 16)
 #define 	AT91C_DDRC2_ADPE_SLOW		(0x1UL << 16)
 #define AT91C_DDRC2_UPD_MR	(0x3UL << 20)
+#define		AT91C_DDRC2_UPD_MR_(x)		((x & 0x03) << 20)
 #define		AT91C_DDRC2_UPD_MR_NO_UPDATE		(0x0UL << 20)
 #define		AT91C_DDRC2_UPD_MR_SHARED_BUS		(0x1UL << 20)
 #define		AT91C_DDRC2_UPD_MR_NO_SHARED_BUS	(0x2UL << 20)
@@ -212,11 +218,9 @@
 #define 	AT91C_DDRC2_DBW_32_BITS		(0x0UL << 4)
 #define 	AT91C_DDRC2_DBW_16_BITS		(0x1UL << 4)
 
-/* -------- HDDRSDRC2_DLL : (HDDRSDRC2 Offset: 0x24) DLL Information Register --------*/
-#define AT91C_DDRC2_MDINC	(0x1UL << 0)
-#define AT91C_DDRC2_MDDEC	(0x1UL << 1)
-#define AT91C_DDRC2_MDOVF	(0x1UL << 2)
-#define AT91C_DDRC2_MDVAL	(0xFFUL << 8)
+/* -------- MPDDRC_HS : (MPDDRC_HS Offset: 0x24) High Speed Register --------*/
+#define AT91C_DDRC2_DIS_ANTICIP_READ	(0x1UL << 2)
+#define AT91C_DDRC2_EN_CALIB           (0x1UL << 5)
 
 /* ------- MPDDRC_LPDDR2_LPR (offset: 0x28) */
 #define AT91C_LPDDRC2_BK_MASK_PASR(value)	(value << 0)
diff --git a/include/arch/at91_sfr.h b/include/arch/at91_sfr.h
index 425dea2..d78eea4 100644
--- a/include/arch/at91_sfr.h
+++ b/include/arch/at91_sfr.h
@@ -45,6 +45,10 @@
 #define SFR_AICREDIR	0x54
 #define SFR_L2CC_HRAMC	0x58
 
+/* -------- SFR_DDRCFG : (SFR Offset: 0x04) DDR Configuration Register -------- */
+#define SFR_DDRCFG_FDQIEN (0x1u << 16) /**< \brief  DDR_DQ Input buffer always on */
+#define SFR_DDRCFG_FDQSIEN (0x1u << 17) /**< \brief DDR_DQS Input buffer always on */
+
 /*
  * Register Fields
  */
diff --git a/include/ddramc.h b/include/ddramc.h
index 9db6fb3..6dc31a4 100644
--- a/include/ddramc.h
+++ b/include/ddramc.h
@@ -45,6 +45,10 @@ extern int ddram_initialize(unsigned int base_address,
 		unsigned int ram_address,
 		struct ddramc_register *ddramc_config);
 
+extern int lpddram1_initialize(unsigned int base_address,
+					unsigned int ram_address,
+					struct ddramc_register *ddramc_config);
+
 extern int lpddr2_sdram_initialize(unsigned int base_address,
 				unsigned int ram_address,
 				struct ddramc_register *ddramc_config);
